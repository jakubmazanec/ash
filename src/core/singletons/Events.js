'use strict!';var _ = require('_');var setImmediate = require('../polyfills/setImmediate');var Construct = require('../classes/Construct');var events;// list of topicsvar	topics = window.topics = {};// Regular expressions used to split event topic stringsvar REGEX_TOPIC = /\s+/;var REGEX_CATEGORY = '/';/** * Triggers callback for a topic. Subsequent arguments will be passed along to the callbacks.   * * @method * @memberof ash.events		 * @param {string} topic Name of the topic; multiple topics are separated by spaces, the topic categories are separated by forward slashes. * @param {...*} [data] Data passed to the callback function.  * @returns {this} * * @example * // some data to pass along... * var data = {foo: 'var'}; * * // simple topic  * ash.events.publish('event', data); * // multiple topics * ash.events.publish('event1 event2', data); * // topic with categories * ash.events.publish('category/event', data); * // etc. * ash.events.publish('category1/category2/event1 category3/event2 event3', data).publish('event4', data); */function publish(async, topic){	var	topicNames = _.isString(topic) ? topic.trim().split(REGEX_TOPIC) : ['*'];	var topicName;	var categories;	var data = Array.apply(null, arguments).slice(1);	var self = this;	async = !!async;	var __publish = function ()	{		for (var k = 0; k < topicNames.length; k++)		{			topicName = topicNames[k];			categories = topicName.split(REGEX_CATEGORY);					// iterate over topics			for (var i in topics)			{				// is topic matching?				if (_.isMatching(topics[i].categories, categories) || topics[i].name == '*' || topicName == '*')				{					// iterate over subscriptions					for (var j = 0; j < topics[i].subscriptions.length; j++)					{						// is target matching?						if (self == topics[i].subscriptions[j].target || topics[i].subscriptions[j].overrideOwner)						{							// if not disabled, first argument will be event object							if (!topics[i].subscriptions[j].noEventArgument)							{								data = [								{									type: topicName,									topic: topics[i].name,									target: self								}].concat(data);							}							/*topics[i].subscriptions[j].callback.apply(topics[i].subscriptions[j].thisArgument, _.union(							[{								type: topicName,								topic: topics[i].name,								target: self							}], data));*/							topics[i].subscriptions[j].callback.apply(topics[i].subscriptions[j].thisArgument, data);							if (typeof topics[i].subscriptions[j] !== 'undefined' && topics[i].subscriptions[j].once)							{								topics[i].subscriptions.splice(j, 1);							} // if						} // if					} // for										} // if			} // for		} // for			};	if (async)	{		setImmediate(__publish);	} else	{		__publish();	}	return null;}/** * Subscribes callback to a topic. * * @method * @memberof ash.events		 * @param {string} topic Name of the topic; multiple topics are separated by spaces, the topic categories are separated by forward slashes. Callback is triggered only if all of the subscription topic's categories are present in the published topic in the same order, eg. publishing 'category1/event' will trigger 'category1', but not 'category1/category2', publishing 'category1/category2/event' will trigger 'category1/category2', but not 'category2/category1'. Topic can be '*', and then is triggered by anything published. * @param {function} callback Callback function; it is called with event parameter (containing original published topic in even.type, subscribed topic in event.topic, and publishing object in event.target) and any parameters passed by publish method * @param {object} [options] The options object. * @param {object} [options.subscribeTo=this] Useful when you want to listen to another object's published events. * @param {boolean} [options.once=false] Callback is triggered only once and then subscription is canceled. * @param {*} [options.thisArgument=this|window] Specifies what will this inside the callback function refer to. If the subscription is global (i.e. to ash.events), default is window, otherwise it's the object to which the subscription belongs. * @param {*} [options.overrideOwner=false] Should subscription owner be overridden? Useful for debugging. * @returns {string} Returns token, which can be used in {@link ash.events.unsubscribe}. * * @example * // create a callback function * var callback = function (event, data) * { * console.log(event.type); * console.log(event.topic); * console.log(event.target); * console.log(data); * console.log(this); * }; *  * // extend prototype of some classes * var Widget1 = {}; * var Widget2 = {}; * _.extend(Widget1.prototype, ash.events); * _.extend(Widget2.prototype, ash.events); * // create new instances * var widget1 = new Widget1(); * var widget2 = new Widget2(); *  * // subscription 1 * widget1.subscribe('category1/category2', callback, {subscribeTo: widget2, thisArgument: widget2}); * // subscription 2 * widget1.subscribe('*', callback, {subscribeTo: widget2, once: true}); * * // some data to pass along... * var data = {foo: 'var'}; * * widget2.publish('category1/event', data); // triggers subscription 2 * widget2.publish('category2/category1/event', data); // triggers subscription 2 * widget2.publish('category1/category2/event', data); // triggers both subscriptions * widget2.publish('category1/category2/event', data); // triggers subscriptions 1 */function subscribe(topic, callback, options){	options = options || {};	var self = this;	// topic is missing, we will use '*', and juggle the remaining arguments	if (_.isFunction(topic))	{		options = callback || {};		callback = topic;		topic = '*';	} else if (_.isObject(topic))	{		// topic can be map of subscriptions...				for (var key in topic)		{			subscribe(key, topic[key], callback);		} // for		return null;	} // if		{		if (!_.isPlainObject(options))		{			throw new Error(options + ' must be a plain object.');		} // if		if (!_.isFunction(callback))		{			throw new Error(callback + ' must be a function.');		} // if	}	var	topicNames = _.isString(topic) ? topic.trim().split(REGEX_TOPIC) : ['*'];	var topicName;	for (var i = 0; i < topicNames.length; i++)	{		topicName = topicNames[i];		if (!topics[topicName])		{			topics[topicName] =			{				name: topicName,				categories: topicName.split(REGEX_CATEGORY),				subscriptions: []			};		} // if		var token = _.uuid();		topics[topicName].subscriptions.push(		{			token: token,			owner: self,			target: options.subscribeTo || self,			callback: callback,			once: !!options.once,			thisArgument: options.thisArgument || self || null,			overrideOwner: !!options.overrideOwner,			noEventArgument: !!options.noEventArgument		}); // push		return token;	} // for		return null;}/** * Cancels subscription. * * @method * @memberof ash.events		 * @param {string} [token] If token is undefined, all subscriptions will be canceled; if token is token returned by {@link ash.events.subscribe}, only that specific subscription will be canceled; if token is topic or list of topics, subscription to those topics will be canceled. * @returns	{this} * * @example * // create a callback function * var callback = function () {}; * * // subscribe... * var token = ash.events.subscribe('category1/category2', callback); * ash.events.subscribe('category3', callback); * ash.events.subscribe('category4', callback); * ash.events.subscribe('event', callback); * * // unsubscribe... * ash.events.unsubscribe(token); * ash.events.unsubscribe('category3 category4'); * ash.events.unsubscribe(); * // in the end, there are no more subscriptions... */function unsubscribe(token/*or topic name*/, callback, context, target){	token = _.isString(token) && token.length > 0 ? token : null;	callback = _.isFunction(callback) ? callback : null;	context = _.isObject(context) ? context : null;	target = _.isObject(target) ? target : null;	var i, j, k;	var self = this;	if (token)	{		var	topicNames = token.trim().split(REGEX_TOPIC);		var topicName;		// iterate over (possible) topic names		for (k = 0; k < topicNames.length; k++)		{			topicName = topicNames[k];			// iterate over topics			for (i in topics)			{				if (topicName == topics[i].name)				{					// token is actually topic; let's iterate over that topic's subscriptions					for (j = 0; j < topics[i].subscriptions.length; j++)					{						// to be deleted, subscribtion must be owned by self, and have right callback, thisArgument, and target if they're specified						if (topics[i].subscriptions[j].owner == self && (!callback || topics[i].subscriptions[j].callback == callback) && (!context || topics[i].subscriptions[j].thisArgument == context) && (!target || topics[i].subscriptions[j].target == target))						{							topics[i].subscriptions.splice(j, 1);						} // if					} // for				} else				{					// find subscription with specified token					for (j = 0; j < topics[i].subscriptions.length; j++)					{						if (topicName == topics[i].subscriptions[j].token)						{							topics[i].subscriptions.splice(j, 1);							return self;						} // if					} // for				} // if			} // for		} // for	} else	{		// delete all subscriptions owned by self		for (i in topics)		{			for (j = 0; j < topics[i].subscriptions.length; j++)			{				// to be deleted, subscribtion must be owned by self, and have right callback, thisArgument, and target if they're specified				if (topics[i].subscriptions[j].owner == self && (!callback || topics[i].subscriptions[j].callback == callback) && (!context || topics[i].subscriptions[j].thisArgument == context) && (!target || topics[i].subscriptions[j].target == target))				{					topics[i].subscriptions.splice(j, 1);				} // if			} // for		} // for	} // if	return null;}/** * Component providing publish/subscribe functionality. Can be used as global "pubsub" bus, or can be extended upon any object. * * @namespace * @memberof ash * * @example * // create a callback function * var callback = function (event, data) { console.log(data.foo) }; * * // subscribe to a topic * ash.events.subscribe('event', callback);  * // trigger an event * ash.events.publish('event', {foo: 'bar'}); * * // extend prototype of some class * var Widget = {}; * _.extend(Widget.prototype, ash.events); * // create new instance * var widget = new Widget(); * // events are bound only for that instace * widget.subscribe('event', callback); * widget.publish('event', {foo: 'bar'}); */var Events = Construct.extend({	constructor: function ()	{		if (events)		{			return events;		}		if (!(this instanceof Events))		{			return new Events();		}		events = this;		return events;	},	trigger: function (/*topic*/)	{		publish.apply(this, [true].concat(_.toArray(arguments)));		return this;	},	triggerAsync: function (/*topic*/)	{		publish.apply(this, [false].concat(_.toArray(arguments)));		return this;	},		on: function (topic, callback, thisArgument)	{		if (_.isFunction(topic))		{			subscribe.call(this, topic, callback,			{				thisArgument: callback			});			} else if (_.isObject(topic))		{			subscribe.call(this, topic,			{				thisArgument: callback			});		} else		{			subscribe.call(this, topic, callback,			{				thisArgument: thisArgument			});		} // if		return this;	}, // on	once: function (topic, callback, thisArgument)	{		if (_.isFunction(topic))		{			subscribe.call(this, topic, callback,			{				once: true,				thisArgument: callback			});			} else if (_.isObject(topic))		{			subscribe.call(this, topic,			{				once: true,				thisArgument: callback			});		} else		{			subscribe.call(this, topic, callback,			{				once: true,				thisArgument: thisArgument			});		} // if		return this;	}, // once	listenTo: function (object, topic, callback, options)	{		if (_.isFunction(topic))		{			subscribe.call(this, topic,			_.assign(			{				subscribeTo: object			}, callback));		} else if (_.isObject(topic))		{						subscribe.call(this, topic,			{				subscribeTo: object			});		} else		{			subscribe.call(this, topic, callback,			{				subscribeTo: object			});		} // if		return this;	}, // listenTo	listenToOnce: function (object, topic, callback)	{		if (_.isFunction(topic))		{			subscribe.call(this, topic, callback,			{				once: true,				subscribeTo: object			});			} else if (_.isObject(topic))		{			subscribe.call(this, topic,			{				once: true,				subscribeTo: object			});		} else		{			subscribe.call(this, topic, callback,			{				once: true,				subscribeTo: object			});		} // if		return this;	}, // listenToOnce	off: function (topic, callback, thisArgument)	{		unsubscribe.call(this, topic, callback, thisArgument);		return this;	}, // off	stopListening: function (object, topic, callback, thisArgument)	{		unsubscribe.call(this, topic, callback, thisArgument, object);		return this;	}, // stopListening	hasListeners: function(/*object*/)	{		var object = _.isObject(arguments[0]) ? arguments[0] : this;		var i, j;		// iterate over all topics and all their subscriptions to find if any has specified target		for (i in topics)		{			for (j = 0; j < topics[i].subscriptions.length; j++)			{				if (topics[i].subscriptions[j].target == object)				{					return true;				} // if			} // for		} // for		return false;	}, // hasListeners	getListeners: function(/*object*/)	{		var object = _.isObject(arguments[0]) ? arguments[0] : this;		var listeners = [];		var i, j;		// iterate over all topics and all their subscriptions to find if any has specified target		for (i in topics)		{			for (j = 0; j < topics[i].subscriptions.length; j++)			{				if (topics[i].subscriptions[j].target == object)				{					listeners.push(topics[i].subscriptions[j].owner);				} // if			} // for		} // for		return listeners;	} // hasListeners});module.exports = Events;